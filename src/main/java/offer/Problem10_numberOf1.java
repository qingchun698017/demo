package offer;

/**
 * Created by wqc on 2017/7/18.
 * 输入一个整数，输出该数二进制表示中1的个数
 * 如9 二进制为1001，则输出2
 */
public class Problem10_numberOf1 {
    /**
     * 我们发现减1的结果是把从最右边一个1开始的所有位都取反了。
     * 这个时候如果我们再把原来的整数和减去1之后的结果做与运算，
     * 从原来整数最右边一个1那一位开始所有位都会变成0。如1100&1011=1000。
     * 也就是说，把一个整数减去1，再和原整数做与运算，会把该整数最右边一个1变成0。
     * 那么一个整数的二进制有多少个1，就可以进行多少次这样的操作。
     */
    public int numberOf1(int n)
    {
        int count = 0;
        while(n != 0)
        {
            count++;
            n = (n-1)&n;
        }
        return count;
    }

    /***
     * 一个很基本的想法是，我们先判断整数的最右边一位是不是1。
     * 接着把整数右移一位，原来处于右边第二位的数字现在被移到第一位了，再判断是不是1。
     * 这样每次移动一位，直到这个整数变成0为止。
     * 现在的问题变成怎样判断一个整数的最右边一位是不是1了。
     * 很简单，如果它和整数1作与运算。由于1除了最右边一位以外，其他所有位都为0。
     * 因此如果与运算的结果为1，表示整数的最右边一位是1，否则是0。
     */
    public int getNumberOf1(int n)
    {
        int count = 0;
        while(n != 0)
        {
            if((n&1)!= 0)
                count++;
            n = n >>1;
        }
        return count;
    }
}
